<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Phosphor: Event Tracing Instrumentation API Spec</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Phosphor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_docs_design_Instrumentation-API.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Event Tracing Instrumentation API Spec </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Date: 2016-04-19</em></p>
<p><em>Author: Will Gardner</em></p>
<p><b>Recommended Reading:</b></p>
<ul>
<li>./One-pager.md "One-pager"</li>
<li>Chromium Project event tracing API: <a href="https://code.google.com/p/chromium/codesearch#chromium/src/base/trace_event/common/trace_event_common.h&amp;q=f:trace_event_common.h">https://code.google.com/p/chromium/codesearch#chromium/src/base/trace_event/common/trace_event_common.h</a></li>
</ul>
<hr/>
<h2>Outline:</h2>
<p>The purpose of this spec is to specify the user API for tooling a C++ application for tracing. The user API will consist of preprocessor macros. The reasoning behind this is twofold, firstly it allows for for trivially compiling out the tracing (e.g. for production or testing performance overhead), secondly it makes it easier to start instrumenting code while the tracing implementation is under development.</p>
<p>This document does not detail the API for initialising tracing or triggering some kind of tracing dump.</p>
<h2>Event Types</h2>
<p>There will be initially three event types:</p>
<ul>
<li>Instant (ie. no duration)</li>
<li>Synchronous (start, stop on same thread and is in theory executing for that entire time - useful for tracing execution time of a function)</li>
<li>Asynchronous (start, stop on any thread and may or may not be actively executed - useful for things like EWOULDBLOCK tracing)</li>
</ul>
<h2>Macro Examples</h2>
<p>Every event has common parameters of category, event_name and, optionally, arguments. Both category and event_name should be fixed cstrings (ie. wonâ€™t go out of scope) - this allows for potential optimisations (e.g. just store the pointer). The category might be just a single category in an initial implementation with a comma separated list in future.</p>
<h3>Synchronous (entry and return)</h3>
<pre class="fragment">TRACE_EVENT(category, event_name, args...)
</pre><p>In this example a start event <code>event_name</code> is logged to <code>category</code> with a variadic number of <code>args</code>. Thread ID and the time are automatically collected. This will also place a variable in the current scope that will log a corresponding end event when it goes out of scope. This might be useful for logging the start and end of an expensive function e.g. </p><pre class="fragment">fdb_status fdb_get_kv(fdb_kvs_handle *handle,
                      const void *key,
                      void **value_out) {
    /* Assuming the disk category is enabled, log the fdb_get_kv
       start event with the handle and the key requested. */
    TRACE_EVENT("disk", "fdb_get_kv", handle, key);

    /* Do something expensive like fetch from disk */
    ...

    /* Automatically add end event for the function call */
    return status;
}
</pre><h3>Synchronous (Explicit)</h3>
<pre class="fragment">TRACE_EVENT_START(category, event_name, args...)
TRACE_EVENT_END(category, event_name)
</pre><p>This example is more or less identical to the previous, except the end of the trace event is explicit. This must be called from a single thread as the start and end events will be matched up even when nested. This can be useful for tracing an event that occurs across functions or in the middle of a function, e.g. acquiring an expensive/global lock: </p><pre class="fragment">DcpResponse* DcpProducer::getNextItem() {
    TRACE_EVENT_START("dcp", "DcpProducer::getNextItem()/get-expensive-lock");
    /* Acquire an expensive lock */
    TRACE_EVENT_END("dcp", "DcpProducer::getNextItem()/get-expensive-lock");

    /* Do stuff with the lock */
}
</pre><h3>Instant</h3>
<pre class="fragment">TRACE_EVENT_INSTANT(category, event_name, args...)
</pre><p>In this example a single event will be logged that is effectively equivalent to the synchronous start event, except without an expectation of a corresponding end event. </p><pre class="fragment">void HashTable::remove(Item* itm) {
    /* Inexpensive function call but worth logging */
    TRACE_EVENT_INSTANT("hashtable", "HashTable::remove", itm-&gt;key);
}
</pre><h3>Asynchronous</h3>
<pre class="fragment">TRACE_ASYNC_EVENT_START(category, event_name, event_id, args...)
TRACE_ASYNC_EVENT_END(category, event_name, event_id)
</pre><p>The primary difference with asynchronous events is that they can occur across threads and out of order which means matching them cannot be inferred, therefore they have an event_id for tracking this. The event_id would be some kind of opaque integer/pointer. Examples include EWOULDBLOCK handling: </p><pre class="fragment">/* On a front-end memcached thread */
ENGINE_ERROR_CODE EvpStore(ENGINE_HANDLE* handle,
                           const void *cookie,
                           item* itm) {

    TRACE_ASYNC_EVENT_START('persist', 'EvpStore/persistTo',
                            cookie, itm-&gt;key);
    /* Add to disk-write queue */

}


/* On a writer thread */
void PersistenceCallback::callback(mutation_result &amp;value) {
    TRACE_ASYNC_EVENT_END("persist", "EvpStore/persistTo",
                          queued_value-&gt;cookie);
    /* Notify memcached */
}</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
